\documentclass[a4paper, titlepage]{article}

\usepackage[utf8]{inputenc} % accents
\usepackage{geometry}         % marges
\usepackage[frenchb]{babel}  % langue
\usepackage{graphicx}         % images
\usepackage{verbatim}         % texte préformaté
\usepackage{hhline}
\usepackage{flafter} 
\usepackage[section]{placeins}
\usepackage{listings}
\usepackage{color}
\usepackage[dvipsnames]{xcolor}

\lstset{language=python,
	  	basicstyle=\ttfamily,
        	        keywordstyle=\color{ForestGreen}\ttfamily,
        	        stringstyle=\color{BrickRed}\ttfamily,
        	        commentstyle=\color{Periwinkle}\ttfamily,
        	        morecomment=[l][\color{magenta}]{\#},
                        emph={checkDefinedRules},          % Custom highlighting
                        emphstyle=\ttb\color{MidnightBlue},    
        	        	frame =tBlR ,rulesep =1mm ,framesep =5mm,framerule =2pt, 
        	        	xrightmargin =-2mm,xleftmargin =5mm ,rulecolor ={\color [gray]	{0.6}},rulesepcolor={\color [gray]{0.9}}
                	}
\lstset{
   basicstyle=\ttfamily
}

\renewcommand{\lstlistingname}{Extrait de code}
\renewcommand{\lstlistlistingname}{List of \lstlistingname s}


\title{Rapport projet Combinatoire}      
\author{-}         
\date{-}          

                              
\begin{document}
%% \maketitle

\section{Réponses attendues pour la méthode count}
Pour la grammaire des arbres :
\begin{center}
\begin{tabular}{|c||c|c|c|c|c|c|c|c|c|c|c|}
\hline n & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\
\hline
\hline count(n, Tree) & 0 & 1 & 1 & 2 & 5 & 14 & 42 & 123 & 429 & 1430
& 4862 \\
\hline count(n, Node) & 0 & 0 & 1 & 2 & 5 & 14 & 42 & 123 & 429 & 1430 & 4862 \\
\hline count(n, Leaf) & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
\hline
\end{tabular}
\end{center}

Pour la grammaire des mots de Fibonacci :
\begin{center}
\begin{tabular}{|l||c|c|c|c|c|c|c|c|c|c|c|}
\hline n & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\
\hline
\hline count(n, Fib) & 1 & 2 & 3 & 5 & 8 & 13 & 21 & 34 & 55 & 89 & 144 \\
\hline count(n, Cas1) & 0 & 2 & 3 & 5 & 8 & 13 & 21 & 34 & 55 & 89 & 144 \\
\hline count(n, Cas2) & 0 & 1 & 1 & 2 & 3 & 5 & 8 & 13 & 21 & 34 & 55\\
\hline count(n, Vide) & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
\hline count(n, CasAu) & 0 & 1 & 2 & 3 & 5 & 8 & 13 & 21 & 34 & 55 & 89\\
\hline count(n, AtomA) & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
\hline count(n, AtomB) & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
\hline count(n, CasBAu) & 0 & 0 & 1 & 2 & 3 & 5 & 8 & 13 & 21 & 34 & 55\\
\hline
\end{tabular}
\end{center}

\section{Grammaires}

\subsection{Alphabet A,B}
\medskip
$ S\ =\ \mathcal{E}\ |\ AS\ |\ BS $ 

$w$ est un mot de la grammaire $A$, $B$ si:
\begin{itemize}
\item soit $w$ est vide
\item soit $w$ est de la forme $Au$ où $u$ est un mot de la grammaire
  $A,B$
\item soit $w$ est de la forme $Bu$ où $u$ est un mot de la grammaire
  $A,B$
\end{itemize}

\subsection{Mots de Dyck}
\medskip
$ S\ =\ \mathcal{E}\ |\ (S)\ |\ S(S) $ 

$w$ est un mot de Dyck si:
\begin{itemize}
\item soit $w$ est vide
\item soit $w$ est de la forme $(u)$ où $u$ est un mot de Dyck
  de Dyck
\item soit $w$ est de la forme $u(v)$ où $u$ et $v$ sont des mots de Dyck
\end{itemize}

\subsection{Mots sur l'alphabet A,B qui n'ont pas trois lettres
  consécutives égales}
\medskip
$ S\ =\ \mathcal{E}\ |\ U\ |\ T $

$ U\ =\ A\ |\ AA\ |\ AT\ |\ AAT$

$ T\ =\ B\ |\ BB\ |\ BT\ |\ BBT$

$w$ est un mot de cette grammaire si:
\begin{itemize}
\item soit $w$ est vide
\item soit $w$ est de la forme $A$, $AA$, $B$, $BB$
\item soit $w$ est de la forme $AT$ ou $AAT$ où $T$ est un mot de la grammaire
  qui commence par $B$
\item soit $w$ est de la forme $BU$ ou $BBU$ où $U$ est un mot de la grammaire
  qui commence par $A$

\end{itemize}

\subsection{Palindromes sur l'alphabet A, B}
\medskip
$ S\ =\ \mathcal{E}\ |\ A\ |\ B\ |\ ASA\ |\ BSB $

$w$ est un mot de la grammaire des palindrome sur $A$, $B$ si:
\begin{itemize}
\item soit $w$ est vide
\item soit $w$ est de la forme $A$ ou $B$
\item soit $w$ est de la forme $AuA$ où $u$ est un palindrome.
\item soit $w$ est de la forme $BuB$ où $u$ est un palindrome.
\end{itemize}

\subsection{Palindromes sur l'alphabet A, B, C}
\medskip
$ S\ =\ \mathcal{E}\ |\ A\ |\ B\ |\ ASA\ |\ BSB\ |\ CSC$

$w$ est un mot de la grammaire des palindrome sur $A$, $B$ si:
\begin{itemize}
\item soit $w$ est vide
\item soit $w$ est de la forme $A$ ou $B$ ou $C$
\item soit $w$ est de la forme $AuA$ où $u$ est un palindrome.
\item soit $w$ est de la forme $BuB$ où $u$ est un palindrome.
\item soit $w$ est de la forme $CuC$ où $u$ est un palindrome.
\end{itemize}

\subsection{Mots sur l'alphabet A,B qui contiennent autant de A que de
B}
\medskip
$ S\ =\ \mathcal{E}\ |\ aTbS\ |\ bUaS$

$ T\ =\ \mathcal{E}\ |\ aTbT$

$ U\ =\ \mathcal{E}\ |\ bTaT$


\section{Calcul de la valuation}

\subsection{Mots de Fibonacci}
\begin{table}[!hbt]
\centering
\small
\setlength\tabcolsep{2pt}
\begin{tabular}{|c|cccccccc|}
\hline $n$ & Fib & Cas1 & Cas2 & Vide & CasAu & AtomA & AtomB & CasBAu\\
\hline
\hline règle & Vide $\cup$ Cas1 & CasAU $\cup$ Cas2 & AtomA $\cup$
AtomB & $\mathcal{E}$ & AtomA*Fib & A & B & AtomB*CasAu\\ 
\hline
\hline
0 & $\infty$ &  $\infty$ & $\infty$ & $\infty$ & $\infty$ & $\infty$ &$\infty$ & $\infty$ \\
1 & $\infty$ &  $\infty$ & $\infty$ & 0 & $\infty$ & 1 & 1 & $\infty$ \\
2 & 0 &  $\infty$ & 1 & 0 & 1 & 1 & 1 & $\infty$ \\
3 & 0 & 1 & 1 & 0 & 1 & 1 & 1 & 2 \\
3 & 0 & 1 & 1 & 0 & 1 & 1 & 1 & 2\\
\hline
\end{tabular}
\end{table}

\newpage
\subsection{Mots de Dyck}
\begin{table}[!hbt]
\centering
\small
\setlength\tabcolsep{2pt}
\begin{tabular}{|c|ccccccc|}
\hline $n$ & Dyck & Casuu & Vide & AtomLPAR & AtomRPAR & Cas(u & Casu) \\
\hline
\hline règle & Vide $\cup$ Casuu & Dyck * Cas(u & $\matchcal{E}$
&``(`` & ``)'' $ & LPAR * Casu) & Dyck * RPAR \\ 
\hline
\hline
0 & $\infty$ &  $\infty$ & $\infty$ & $\infty$ & $\infty$ & $\infty$ &$\infty$ \\
1 & $\infty$ &  $\infty$ & 0 & 1 & 1 & $\infty$ &$\infty$ \\
2 & 0 &  $\infty$ & 0 & 1 & 1 & $\infty$ &$\infty$ \\
3 & 0 &  $\infty$ & 0 & 1 & 1 & $\infty$ & 1 \\
4 & 0 &  $\infty$ & 0 & 1 & 1 & 2 & 1 \\
5 & 0 & 2 & 0 & 1 & 1 & 2 & 1 \\
6 & 0 & 2 & 0 & 1 & 1 & 2 & 1 \\

\hline

\end{tabular}
\end{table}




\begin{table}[!hbt]
\subsection{Mots sur l'alphabet A,B}
\centering
\small
\setlength\tabcolsep{2pt}
\begin{tabular}{|c|ccccccc|}
\hline $n$ & AB & AtomA & AtomB & CasAB & Vide & CasAu & CasBu \\
\hline
\hline règle & Vide $\cup$ CasAB & A & B & CasAu $\cup$ CasBu &
$\mathcal{E}$ & AtomA * AB & AtomB * AB \\
\hline
\hline
0 & $\infty$ &  $\infty$ & $\infty$ & $\infty$ & $\infty$ & $\infty$ &$\infty$ \\
1 & $\infty$ &  1 & 1 & $\infty$ & 0 & $\infty$ &$\infty$ \\
2 & 0 &  1 & 1 & $\infty$ & 0 & 1 & 1 \\
3 & 0 &  1 & 1 & 1 & 0 & 1 & 1 \\
4 & 0 &  1 & 1 & 1 & 0 & 1 & 1 \\


\hline

\end{tabular}
\end{table}

\begin{table}[!hbt]
\subsection{Mots qui n'ont pas trois lettres consécutives égales sur A, B}
\centering
\small
\setlength\tabcolsep{2pt}
\begin{tabular}{|c|ccccccccc|}
\hline $n$ & Three & Vide & AtomA & AtomB & AA & BB & S & U & U1 \\
\hline
\hline règle & Vide $\cup$ S & $\mathcal{E}$ & A & B & AtomA*AtomA &
AtomB*AtomB & U $\cup$ T & AtomA $\cup$ U1 & AA $\cup$ U2\\
\hline
\hline
0 & $\infty$ &  $\infty$ & $\infty$ & $\infty$ & $\infty$ & $\infty$ &
$\infty$ & $\infty$ & $\infty$ \\
1 & $\infty$ & 0  & 1 & 1 & $\infty$ & $\infty$ &
$\infty$ & $\infty$ & $\infty$ \\
2 & 0 & 0  & 1 & 1 & 2 & 2 &
$\infty$ & 1 & $\infty$ \\
3 & 0 & 0  & 1 & 1 & 2 & 2 &
1& 1 & 2 \\
4 & 0 & 0  & 1 & 1 & 2 & 2 &
1& 1 & 2 \\
5 & 0 & 0  & 1 & 1 & 2 & 2 &
1& 1 & 2 \\
6 & 0 & 0  & 1 & 1 & 2 & 2 &
1& 1 & 2 \\

\hline
\end{tabular}

\vspace{1cm}
\begin{tabular}{|c|cccccccc|}
\hline $n$ & U2 & AT & AAT & T & T1 & T2 & BU & BBU \\
\hline
\hline règle & AT $\cup$ AAT & AtomA * T & AtomA * AT & AtomB $\cup$
T1 & BB $\cup$ T2 & BU $\cup$ BBU & AtomB * U & AtomB * BU\\
\hline
0 & $\infty$ &  $\infty$ & $\infty$ & $\infty$ & $\infty$ & $\infty$ &
$\infty$ & $\infty$  \\
1 & $\infty$ &  $\infty$ & $\infty$ & $\infty$ & $\infty$ & $\infty$ &
$\infty$ & $\infty$  \\
2 & $\infty$ &  $\infty$ & $\infty$ & 1 & $\infty$ & $\infty$ &
$\infty$ & $\infty$  \\
3 & $\infty$ & 2 & $\infty$ & 1 & 2 & $\infty$ &
2 & $\infty$  \\
4 & 2 & 2 & 3 & 1 & 2 & $\infty$ &
2 & 3  \\
5 & 2 & 2 & 3 & 1 & 2 & 2 &
2 & 3  \\
6 & 2 & 2 & 3 & 1 & 2 & 2 &
2 & 3  \\

\hline
\end {tabular}
\end{table}

\newpage
\begin{table}[!hbt]
\subsection{Palindromes sur A,B}
\centering
\small
\setlength\tabcolsep{2pt}
\begin{tabular}{|c|cccccc|}
\hline $n$ & Pal & Vide & AtomA & AtomB & S & S1\\
\hline
\hline règle & Vide $\cup$ S & $\mathcal{E}$ & A & B & AtomA $\cup$ S1
& AtomB $\cup$ S2 \\
\hline
\hline
0 & $\infty$ &  $\infty$ & $\infty$ & $\infty$ & $\infty$ & $\infty$\\
1 & $\infty$ & 0 & 1 & 1 & $\infty$ & $\infty$\\
2 & 0 & 0 & 1 & 1 & 1 & 1\\
3 & 0 & 0 & 1 & 1 & 1 & 1\\
4 & 0 & 0 & 1 & 1 & 1 & 1\\
5 & 0 & 0 & 1 & 1 & 1 & 1\\
6 & 0 & 0 & 1 & 1 & 1 & 1\\

\hline
\end{tabular}

\vspace{1cm}

\begin{tabular}{|c|ccccc|}
\hline $n$ & S2 & ASA & ASA1 & BSB & BSB1  \\
\hline
\hline règle & ASA $\cup$ BSB & AtomA * ASA1 & Pal * AtomA &
AtomB * BSB1 & Pal * AtomB\\
\hline
\hline
0 & $\infty$ &  $\infty$ & $\infty$ & $\infty$ & $\infty$ \\
1 & $\infty$ &  $\infty$ & $\infty$ & $\infty$ & $\infty$ \\
2 & $\infty$ &  $\infty$ & $\infty$ & $\infty$ & $\infty$ \\
3 & $\infty$ &  $\infty$ & 1 & $\infty$ & 1 \\
4 & $\infty$ &  2 & 1 & 2 & 1 \\
5 & 2 &  2 & 1 & 2 & 1 \\
6 & 2 &  2 & 1 & 2 & 1 \\

\hline
\end{tabular}
\end{table}

\begin{table}[!hbt]
\subsection{Palindromes sur A,B,C}
\centering
\small
\setlength\tabcolsep{2pt}
\begin{tabular}{|c|ccccccccc|}
\hline $n$ & Pal & Vide & AtomA & AtomB & AtomC & S & S1 & S2 & S3\\
\hline
\hline règle & Vide $\cup$ S & $\mathcal{E}$ & A & B & C & AtomA $\cup$ S1
& AtomB $\cup$ S2 & AtomC $\cup$ S3 & ASA $\cup$ S4 \\
\hline
\hline
0 & $\infty$ &  $\infty$ & $\infty$ & $\infty$ & $\infty$ & $\infty$ & $\infty$ & $\infty$ & $\infty$ \\
1 & $\infty$ & 0 & 1 & 1 & 1 & $\infty$ & $\infty$ & $\infty$ & $\infty$ \\
2 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 1 & $\infty$ \\
3 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 1 & $\infty$ \\
4 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 1 & $\infty$ \\
5 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 1 & 2 \\
6 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 1 & 2 \\

\hline
\end{tabular}


\vspace{1cm}

\begin{tabular}{|c|ccccccc|}
\hline $n$  & S4 & ASA & ASA1 & BSB & BSB1 & CSC & CSC1  \\
\hline
\hline règle & BSB $\cup$ CSC & AtomA * ASA1 & Pal * AtomA &
AtomB * BSB1 & Pal * AtomB & AtomC * CSC1 & Pal * AtomC\\
\hline
\hline
0 & $\infty$ &  $\infty$ & $\infty$ & $\infty$ & $\infty$ & $\infty$ & $\infty$ \\
1 & $\infty$ &  $\infty$ & $\infty$ & $\infty$ & $\infty$ & $\infty$ & $\infty$ \\
2 & $\infty$ &  $\infty$ & $\infty$ & $\infty$ & $\infty$ & $\infty$ & $\infty$ \\
3 & $\infty$ &  $\infty$ & 1 & $\infty$ & 1 & $\infty$ & 1 \\
4 & $\infty$ &  2 & 1 & 2 & 1 & 2 & 1 \\
5 & 2 & 2 & 1 & 2 & 1 & 2 & 1 \\
6 & 2 & 2 & 1 & 2 & 1 & 2 & 1 \\

\hline
\end{tabular}


\end{table}

\newpage

\subsection{Palindromes sur A,B,C}

\begin{table}[!hbt]
\centering
\small
\setlength\tabcolsep{2pt}
\begin{tabular}{|c|ccccccccc|}
\hline $n$ & Pal & Vide & AtomA & AtomB & AtomC & S & S1 & S2 & S3\\
\hline
\hline règle & Vide $\cup$ S & $\mathcal{E}$ & A & B & C & AtomA $\cup$ S1
& AtomB $\cup$ S2 & AtomC $\cup$ S3 & ASA $\cup$ S4 \\
\hline
\hline
0 & $\infty$ &  $\infty$ & $\infty$ & $\infty$ & $\infty$ & $\infty$ & $\infty$ & $\infty$ & $\infty$ \\
1 & $\infty$ & 0 & 1 & 1 & 1 & $\infty$ & $\infty$ & $\infty$ & $\infty$ \\
2 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 1 & $\infty$ \\
3 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 1 & $\infty$ \\
4 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 1 & $\infty$ \\
5 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 1 & 2 \\
6 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 1 & 2 \\

\hline
\end{tabular}

\vspace{1cm}

\begin{tabular}{|c|ccccccc|}
\hline $n$  & S4 & ASA & ASA1 & BSB & BSB1 & CSC & CSC1  \\
\hline
\hline règle & BSB $\cup$ CSC & AtomA * ASA1 & Pal * AtomA &
AtomB * BSB1 & Pal * AtomB & AtomC * CSC1 & Pal * AtomC\\
\hline
\hline
0 & $\infty$ &  $\infty$ & $\infty$ & $\infty$ & $\infty$ & $\infty$ & $\infty$ \\
1 & $\infty$ &  $\infty$ & $\infty$ & $\infty$ & $\infty$ & $\infty$ & $\infty$ \\
2 & $\infty$ &  $\infty$ & $\infty$ & $\infty$ & $\infty$ & $\infty$ & $\infty$ \\
3 & $\infty$ &  $\infty$ & 1 & $\infty$ & 1 & $\infty$ & 1 \\
4 & $\infty$ &  2 & 1 & 2 & 1 & 2 & 1 \\
5 & 2 & 2 & 1 & 2 & 1 & 2 & 1 \\
6 & 2 & 2 & 1 & 2 & 1 & 2 & 1 \\

\hline
\end{tabular}
\end{table}

\subsection{Mots sur A,B qui contiennent autant de A que de B}

\begin{table}[!hbt]
\centering
\small
\setlength\tabcolsep{2pt}
\begin{tabular}{|c|cccccccccc|}
\hline $n$ & Vide & AtomA & AtomB & S & S1 & T & U & aTbS & TbS & bS\\
\hline
\hline règle & $\mathcal{E}$ & A & B &  $\mathcal{E}$ $\cup$ S1 &
aTbS $\cup$ bUaS &  $\mathcal{E}$ $\cup$ aTbT &  $\mathcal{E}$ $\cup$
bUaU & A * TbS & T * bS & B * S  \\
\hline
\hline
0 & $\infty$ &  $\infty$ & $\infty$ & $\infty$ & $\infty$ & $\infty$ &
$\infty$ & $\infty$ & $\infty$  & $\infty$  \\
1 & 0 & 1 & 1 & $\infty$ & $\infty$ & $\infty$ &
$\infty$ & $\infty$ & $\infty$  & $\infty$  \\
2 & 0 & 1 & 1 & 0 & $\infty$ & 0 &
0 & $\infty$ & $\infty$  & $\infty$  \\
3 & 0 & 1 & 1 & 0 & $\infty$ & 0 & 0 & $\infty$ & $\infty$  & 1  \\
4 & 0 & 1 & 1 & 0 & $\infty$ & 0 & 0 & $\infty$ & 1 & 1  \\
5 & 0 & 1 & 1 & 0 & $\infty$ & 0 & 0 & 2 & 1 & 1  \\
6 & 0 & 1 & 1 & 0 & 2 & 0 & 0 & 2 & 1 & 1  \\
7 & 0 & 1 & 1 & 0 & 2 & 0 & 0 & 2 & 1 & 1  \\

\hline
\end{tabular}

\vspace{1cm}

\begin{tabular}{|c|ccccccccc|}
\hline $n$ & bUaS & UaS & aS & aTbT & TbT & bT & bUaU & UaU & aU \\
\hline
\hline règle & B * UaS  & U * aS & A * S & A * TbT & T * bT & B * T & B * UaU & U
* aU & A * U\\
\hline
\hline
0 & $\infty$ &  $\infty$ & $\infty$ & $\infty$ & $\infty$ & $\infty$ &
$\infty$  & $\infty$ & $\infty$ \\
1 & $\infty$ &  $\infty$ & $\infty$ & $\infty$ & $\infty$ & $\infty$ &
$\infty$  & $\infty$ & $\infty$ \\
2 & $\infty$ &  $\infty$ & $\infty$ & $\infty$ & $\infty$ & $\infty$ &
$\infty$  & $\infty$ & $\infty$ \\
3 & $\infty$ &  $\infty$ & 1 & $\infty$ & $\infty$ & 1 &
$\infty$  & $\infty$ & 1 \\
4 & $\infty$ & 1 & 1 & $\infty$ & 1  & 1 &
$\infty$  & 1 & 1 \\
5 & 2 & 1 & 1 & 2 & 1 & 1 & 2  & 1 & 1 \\
6 & 2 & 1 & 1 & 2 & 1 & 1 & 2  & 1 & 1 \\
7 & 2 & 1 & 1 & 2 & 1 & 1 & 2  & 1 & 1 \\

\hline
\end{tabular}
\end{table}


\section{Fonction qui vérifie qu'une grammaire est correcte}

Pour vérifier qu'une grammaire est correcte, on parcourt toutes les
règles de la grammaire et pour chaque règle, s'il s'agit d'une règle
de type ConstructorRule, on vérifie si les deux règles qu'elle possède
en attributs sont définies dans la grammaire.

\lstset{caption={}, captionpos=b} 
\begin{lstlisting}
def checkDefinedRules (grammar):
   for ruleId in grammar:
     rule = grammar[ruleId]
     if isinstance(rule, R.ConstructorRule):
       fst, snd = rule.parameters
       if not (fst in grammar):
         raise IncorrectGrammar(fst+" rule not defined in grammar")
       if not (snd in grammar):
         raise IncorrectGrammar(snd+" rule not defined in grammar")
\end{lstlisting}

\section {Structure du programme}

Le projet est composé de 7 fichiers, et a été développé avec Python 3.5:\\
\begin{itemize}
\item Rules.py : contient les classes AbstractRule, ConstructorRule,
  ConstantRule, UnionRule, ProductRule, SingletonRule, EpsilonRule\\
\item Grammars.py : contient la déclaration des grammaires de la
  question 2.2, des fonctions qui calculent des suites qui
  correspondent au nombre d'objets créés par une grammaire (ce point
  est expliqué plus en détail dans la partie suivante) ainsi qu'un dictionnaire qui associe à un nom de
  grammaire une liste qui contient la grammaire, la première règle de
  la grammaire et une fonction qui calcule la cardinalité.\\
\item CRules.py : contient les classes permettant d'implémenter les
  grammaires condensées (plus de détails dans la partie ??\\
\item GrammarsC.py : contient les déclarations de grammaires
  condensées. ?? Pas au max pour lisibilité\\
\item Tree.py : contient la classe BinaryTree du TP3\\
\item Project.py : contient les fonctions permettant d'initialiser les
  grammaires et les fonctions de tests\\
\item Demo.ipynb : contenu similaire à Project.py sous forme de
  notebook pour la démonstration\\
  
\end{itemize}

\section{Tests de cohérence génériques}

Pour toute règle $r$ d'une grammaire, pour tout entier $n$ positif ou
nul, les propriétés suivantes doivent être vérifiées :
\begin{itemize}
\item La longueur de la list générée par $r.list(n)$ doit être égale
  a $r.count(n)$\\
  
\item Si on applique la fonction $r.rank$ à chaque élement de la liste
  générée par $r.list(n)$, on doit obtenir une liste égale à
  $list(range(r.count(n))$\\
  
\item Si on applique la fonction $r.unrank$ à chaque élément de la
  liste $range(r.count(n))$, on doit obtenir une liste égale à $r.list(n)$\\
  
\item On ne peut pas générer de
  mots ayant une taille inférieure à la valeur de la valuation de la
  règle\\
  
\item Pour toutes les fonctions, pour toutes les règles, un paramètre négatif
  provoque une exception.\\

\item Aucune règle ne doit avoir pour valuation $\infty$\\

\item Si $r$ est une $EpsilonRule$ alors $count(n) = 0\ si\ n \neq 0$
  et $count(n) = 1$ sinon \\
  
\item Si $r$ est une $SingletonRule$ alors $count(n) = 0\ si\ n \neq
  1$ et $count(n)=1$ sinon \\

\item Un appel à $r.unrank(n, i)$ avec $i \geq r.count(n)$ doit provoquer
  une exception\\

\item Un appel à $r.rank(obj)$ où $r$ est une règle de type
  $ConstantRule$ provoque une exception si $obj$ n'est pas égal à
  l'objet passé en argument au constructeur de la règle.\\
  
\item S'il existe une suite $U_n$ qui dénombre les objets de la
  grammaire, alors $\forall n \geq 0$, on doit avoir $U_n =
  r.count(n)$\\
  ?? AJOUTER GRAMMAIRE -> SUITES OEIS
  
\end{itemize}

\section {Ajout des fonctions : valuation, count, random, list,  unrank}

Pour le calcul des valuations d'une grammaire, on parcourt toutes les
règles en mettant à jour les valuations pour les règles de type
$ConstructorRule$ en boucle (puisque les valuations des règles de type
$ConstantRule$ sont constantes) jusqu'à atteindre un point fixe.
Les règles de type $ConstructorRule$ possèdent deux méthodes :
get\_valuation qui retoune la valeur de l'attribut valuation, et
update\_valuation qui met à jour la valuation. \\

Pour les autres fonctions (count, random, list, unrank), on implémente
les algorithmes de l'énoncé en ajoutant des vérifications pour
respecter la spécification décrite dans la partie précédente.

?? Ajouter explication fonction unrank

\section {Ajout de la fonction rank}

\subsection {Ajout de rank dans Rules.py}
Pour ajouter la fonction rank aux grammaires on modifie les
constructeurs des classes UnionRule et ProductRule.
On aurait pu ajouter le nouveau paramètre au constructeur de la
classe ConstructorRule, mais les fonctions ajoutées ayant des
signatures différentes en fonction du cas (Union ou Product), on
préfère ajouter le nouveau paramètre à chaque classe, pour plus de
cohérence.\\


Pour la classe UnionRule, le nouvel attribut est nommé
$\_derive\_from\_first$, et correspond à une fonction qui retourne
vrai si l'argument qui lui est passé en paramètre à été dérivé par la
première règle qui compose l'union et faux sinon.\\


Pour la classe ProductRule, le nouvel attribut est nommé
$\_get\_pair$, et correspond à une fonction qui prend un mot de la
grammaire et le sépare en une paire dans laquelle le premier (resp. second) élément
est la partie du mot dérivée par la première (resp. seconde) règle.\\


Afin de maintenir la possibilité de déclarer des grammaires sans avoir
à écrire les fonctions de séparation, la fonction est un attribut
optionnel du constructeur. L'appel à la fonction $rank$ d'une règle
pour laquelle la fonction n'a pas été fournie provoque une exception
de type $NotImplementedError$. \\

Pour effectuer le calcul de $rank$, il est nécessaire d'avoir une
méthode qui permet de calculer la taille d'un objet. Dans notre
implémentation, nous utilisons la fonction python $\_\_len\_\_$ pour
obtenir la longueur d'un objet. Il est donc nécessaire que les objets
de la grammaire possèdent une définition pour $\_\_len\_\_$.\\

L'algorithme utilisé pour le calcul de $r.rank(obj)$ est :\\

\begin{itemize}
  
\item Si $r$ est de type $EpsilonRule$ ou $SingletonRule$ alors si
  $obj$ est égal à l'objet passé au constructeur, on retourne 0 sinon on
  lance une exception $ValueError$.\\

\item Si $r$ est de type $UnionRule(A, B)$, alors si $obj$ dérive de
  $A$ on retourne $A.rank(obj)$ sinon on retorune $A.count(len(obj)) +
  B.rank(obj)$ .\\

\item Si $r$ est de type $ProductRule(A, B)$, avec $obj = (obj_{left},
  obj_{right})$ alors on calcule le nombre d'objets $o =
  (o_{left}, o_{right})$ tels que $len(o_{left}) < len(obj_{left})$,
  auquel on ajoute le rang de $obj$ dans la classe des objets de
  taille $(left, right)$ avec la formule $A.rank(o_{left}) +
  B.count(len(o_{right})) + B.rank(o_{right})$.\\
  
\end{itemize}

\subsection{Exemple de fonctions à ajouter aux grammaires pour obtenir
  rank}

Les fonctions spécifiques aux règles des grammaires pour calculer le
rang ont été ajoutées dans le fichier Grammars.py. On présente ici,
trois règles pour illustrer comment écrire ces fonctions.\\
\pagebreak
\lstset{caption={}, captionpos=b} 
\begin{lstlisting}
  # Regles extraites de la grammaire des mots de Fibonacci

  "Fib"   : R.UnionRule("Vide", "Cas1", lambda s : s == "")

  "CasAu" : R.ProductRule("AtomA", "Fib", "".join,
  lambda s : s = (s[0], s[1:]))

  # Regle extraite le la grammaire des mots de Dyck

  "Casuu" : R.ProductRule("Dyck", "Cas(u", "".join, sep_dyck)

  #avec

  def sep_dyck (s):
    i_lpar = 0
    count = 0
    for i in range(len(s)):
        if s[i] == "(" and count == 0:
            i_lpar = i
            count += 1
        elif s[i] == "(":
            count += 1
        else:
            count -= 1
    return (s[:i_lpar], s[i_lpar:])

\end{lstlisting}
\vspace{1cm}
\begin{itemize}
\item Pour la règle Fib, il est simple de distinguer les cas : si le mot est
Vide, alors il a forcément été généré par la règle vide (car Cas1 ne
permet pas de générer le mot vide).\\
\item Pour la règle CasAu, on remarque que la partie générée par la règle de
gauche est toujours AtomA, donc on peut séparer le mot après le
premier caractère.\\
\item Pour la règle Casuu, on remarque en observant la grammaire complète
que le mot généré par "Cas(u" commence à la dernière parenthèse
ouvrante parmis les parenthèses situées au niveau le plus 'extérieur'
du mot.\\

\section{Caching}
Comparaison temps exec avec caching et sans\\
Comparaison temps en fonction des fonctions mémoisées\\
Comparaison mémoisation python2 vs python3 ?\\

\section{Ajout des Grammaires Condensées}


Expliquer traduction\\
Création de nom de règle\\
-> Grammaires condensées dans GrammarsC (pas totalement pour
lisibilité)\\
On execute les test sur les GrammarsC\\
+ Eventuellement comparaison des résultats GrammairesCondensées vs
GrammairesNonCondensées.\\~

\section{Constructeur Bound}
Explication\\
- list concat\\
- count sum\\
- unrank et rank\\
Créer tests ?\\

\section {Sequence}
Montrer traduction\\ 
Montrer utilisation pour réécriture de DyckGram\\

\end{document}
