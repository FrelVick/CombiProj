# -*- coding: utf-8 -*
from abc import ABCMeta, abstractmethod
# from functools import lru_cache
import random

#python-course.eu
def memoizeu (f):
    memo = {}
    def helper(s, n, i):
        if (s, n, i) not in memo:
            memo[(s, n, i)] = f (s, n, i)
        return memo[(s, n, i)]
    return helper

def memoizer (f):
    memo = {}
    def helper(s, o):
        if (s, str(o)) not in memo:
            memo[(s, str(o))] = f (s, o)
        return memo[(s, str(o))]
    return helper

# Classe dont hérite toutes les règles
class AbstractRule:
    __metaclass__ = ABCMeta

    def __init__(self):
        self._grammar = {}

    def _set_grammar(self, gram):
        self._grammar = gram

class ConstantRule(AbstractRule):
    __metaclass__ = ABCMeta

    def __init__(self, obj):
        super(ConstantRule, self).__init__()
        self._object = obj

    @abstractmethod
    def valuation(self):
        ''' Return valuation '''
        
    @abstractmethod
    def count(self, i):
        ''' Return number of object of weight i '''

    @abstractmethod
    def list(self, i):
        '''Return list of all objects of weight i'''
        

class EpsilonRule(ConstantRule) :
    
    def __init__(self, obj):
        super(EpsilonRule, self).__init__(obj)
        # La valuation d'une règle Epsilon est toujours 0
        self.__valuation = 0
        
    def valuation(self):
        return self.__valuation

    # La règle Epsilon ne produit qu'un seul objet qui est de poids 0
    def count(self, i):
        if i < 0 : 
            raise ValueError("Epsilon rule COUNT : Weight must be positive or null")
        if i == 0:
            return 1
        return 0

    def list(self, i):
        if i < 0:
            raise ValueError("Epsilon rule LIST : Weight must be positive or null")
        if i == 0:
            return [self._object]
        return []
    
    @memoizeu
    def unrank(self, n, i):
        if i == 0 and n == 0 :
            return self._object
        raise ValueError("Epsilon rule UNRANK : only one object of weight and rank 0")
    
    @memoizer
    def rank(self, obj):
        if obj == self._object:
            return 0
        else:
            raise ValueError("Epsilon rule RANK : object passed as arg not generated by epsilon rule")

    def random(self, n):
        return self._object
        
    '''
    Fonctions de conversion en chaine de caractères, et d'affichage
    pour le débugage '''

    def __str__(self):
        return "EpsilonRule("+ str(self._object) +")"
        
    def __print__(self):
        print(str(self))


class SingletonRule(ConstantRule) :
    
    def __init__(self, obj):
        super(SingletonRule, self).__init__(obj)
        # La valuation d'une règle singleton est toujours 1
        self.__valuation = 1

    def valuation(self):
        return self.__valuation

    def count(self, i):
        if i < 0 : 
            raise ValueError("Singleton rule COUNT :Weight must be positive or null")
        if i == 1:
            return 1
        return 0
    
    def list(self, i):
        if i < 0:
            raise ValueError("Singleton rule LIST : Weight must be positive or null")
        if i == 1:
            return [self._object]
        return []
       
    @memoizeu
    def unrank(self, n, i):
        if i == 0 and n == 1:
            return self._object
        raise ValueError("Singleton rule UNRANK : only one object of rank 0 and weight 1")
    
    @memoizer
    def rank(self, obj):
        if obj == self._object:
            return 0
        else:
            raise ValueError("Singleton rule RANK : object passed as arg not\
            generated by singleton rule")

    def random(self, n):
        return self._object

    '''
    Fonctions de conversion en chaine de caractères, et d'affichage
    pour le débugage '''
   
    def __str__(self):
        return "SingletonRule("+str(self._object)+")"

    def __print__(self):
        print(str(self))

class ConstructorRule(AbstractRule):
    __metaclass__ = ABCMeta
     
    def __init__(self, fst, snd):
        super(ConstructorRule, self).__init__()
        # Avant calculs, valuation +inf
        self._valuation = float('inf')
        self._parameters = (fst, snd)

    def valuation(self):
        return self._valuation

    def get_param_rules(self):
        p1, p2 = self._parameters
        return (self._grammar[p1], self._grammar[p2])

    @abstractmethod
    def _calc_valuation(self):
        """update valuation"""
   
    @abstractmethod
    def count(self, i):
        ''' Return number of object of weight i '''

    @abstractmethod
    def list(self, i):
        '''Return list of all objects of weight i'''

    @abstractmethod
    def unrank(self, n, i):
        '''Return object of rank i among objects of size n'''

    ''' Correspond à un pas du calcul de la valuation pour une règle de constructeur:
    on récupère les valuations des règles paramètres et on calcule la valuation de la règle 
    courante '''
    def _update_valuation(self):
        v1 = self._grammar[self._parameters[0]].valuation()
        v2 = self._grammar[self._parameters[1]].valuation()
        self._calc_valuation(v1, v2)

    def random(self, n):
        return self.unrank(n, random.randrange(self.count(n)))
        
      
class UnionRule(ConstructorRule):

    def __init__(self, fst, snd, f = None):
        super(UnionRule, self).__init__(fst, snd)
        # Cette fonction doit etre fournie à la règle pour permettre
        # l'utilisation de la fonction rank, elle doit retourner vrai
        # si l'objet passé en argument dérive de la première règle
        self._derive_from_first = f

    def _calc_valuation(self, v1, v2):
        self._valuation =  min(v1, v2)
       
    def count(self, i):
        if i < 0 : 
            raise ValueError("Union rule COUNT : Weight must be positive or null")
        # r0 = self._grammar[self._parameters[0]]
        # r1 = self._grammar[self._parameters[1]]
        r0, r1 = self.get_param_rules()
        return r0.count(i) + r1.count(i)

    def list(self, i):
        if i < 0 :
            raise ValueError("Union rule LIST : size must be positive or null")
        fst, snd = self.get_param_rules()
        # fst, snd = self._parameters
        # fst, snd = self._grammar[fst], self._grammar[snd]
        return fst.list(i) + snd.list(i)

    @memoizeu
    def unrank(self, n, i):
        if i >= self.count(n) :
            raise ValueError("Union rule UNRANK: rank is greater than the cardinal\
            of the set of objects of weight n")
        if i < 0:
            raise ValueError("Union rule UNRANK: rank must be positive or null")
        else:
            # fst, snd = self._parameters
            # fst, snd = self._grammar[fst], self._grammar[snd]
            fst, snd = self.get_param_rules()
            # L'objet de rang i dérive de la première règle
            if i < fst.count(n):
                return fst.unrank(n, i)
            # L'objet de rang i dérive de la seconde règle
            else:
                return snd.unrank(n, i - fst.count(n))
    @memoizer
    def rank(self, obj):
        if (self._derive_from_first == None):
            raise NotImplementedError("To call rank, provide function as arg")
        # fst, snd = self._parameters
        # fst, snd = self._grammar[fst], self._grammar[snd]
        fst, snd = self.get_param_rules()
        if self._derive_from_first(obj):
            return fst.rank(obj)
        else:
            return fst.count(len(obj)) + snd.rank(obj)

    def __str__(self):
        fst, snd = self._parameters
        # fst, snd = self._grammar[fst], self._grammar[snd]
        return "UnionRule("+str(fst)+", "+str(snd)+")"

    def __print__(self):
        print(str(self))

class ProductRule(ConstructorRule):

    def __init__(self, fst, snd, cons, f = None):
        super(ProductRule, self).__init__(fst, snd)
        self._constructor = cons
        # La fonction f est une fonction qui doit etre passée en argument au constructeur
        # pour pouvoir appeler la fonction rank. Cette fonction retourne un couple dont le 
        # premier élément a été dérivé de la première règle et le second à été dérivé de la s
        # seconde règle.
        self._get_pair = f

    def _calc_valuation(self, v1, v2):
        self._valuation =  v1 + v2

    def count(self, i):
        if i < 0 : 
            raise ValueError("Weight must be positive or null")
        # r1 = self._grammar[self._parameters[0]]
        # r2 = self._grammar[self._parameters[1]]
        r1, r2 = self.get_param_rules()
        v1 = r1.valuation()
        v2 = r2.valuation()
        res = 0
        for i1 in range (v1, i + 1):
            if (i - i1 >= v2):
                res += r1.count(i1) * r2.count(i - i1)
        return res
                

    def list(self, i):
        if i < 0:
            raise ValueError("Product rule LIST: size must be positive or null")
        # fun = self._constructor
        fst, snd = self.get_param_rules()
        # fst, snd = self._parameters
        #        fst, snd = self._grammar[fst], self._grammar[snd]
        l = []
        v1 = fst.valuation()
        v2 = snd.valuation()
        # On construit les objets à partir de couples de taille (0, n), (1, n-1), (2, n -2), ...,
        # (n, 0)
        for i1 in range (v1, i + 1):
            if (i - i1 >= v2):
                l1 = fst.list(i1)
                l2 = snd.list(i - i1)
                for x in l1:
                    for y in l2:
                        l.append(self._constructor([x, y]))
        return l
        
    @memoizeu
    def unrank(self, n, i):
        if i >= self.count(n):
            raise ValueError("Product rule UNRANK :  rank is greater than the cardinal\
            of the set of objects of weight n")
        if i < 0:
            raise ValueError("Product rule UNRANK: rank must be positive or null")
        total = 0
        # fst, snd = self._parameters
        # fst, snd = self._grammar[fst], self._grammar[snd]
        fst, snd = self.get_param_rules()
        for j in range(n+1):
            total = fst.count(j) * snd.count(n - j )
            if (i < total):
                return self._constructor([fst.unrank(j, i//snd.count(n-j)), 
                                          snd.unrank(n-j, i%snd.count(n-j))])
            j += 1
            i -= total

    @memoizer
    def rank(self, obj):
        if (self._get_pair == None):
            raise NotImplementedError("To call rank, provide function as arg")
     
        # fst, snd = self._parameters
        # fst, snd = self._grammar[fst], self._grammar[snd]
        fst, snd = self.get_param_rules()
        e1, e2 = self._get_pair(obj)
        s = len(e1) + len(e2)
        n = 0
        for i in range (len(e1)):
            n += fst.count(i) * snd.count(s - i)
        return n + fst.rank(e1) * snd.count(len(e2)) + snd.rank(e2)
        
    def __str__ (self):
        fst, snd = self._parameters
        # fst, snd = self._grammar[fst], self._grammar[snd]
        return "ProductRule("+str(fst)+", "+str(snd)+")"

    def __print__(self):
        print(str(self))

# Pour représenter tous les objets dérivant d'une règle
# de taille entre min (inclus) et max (exclus)
class Bound:
    
    def __init__(self, rule, min, max):
        self._rule = rule
        self._min = min
        self._max = max

    def count(self):
        count = 0
        for i in range (self._min, self._max):
            count += self._rule.count(i)
        return count

    def list(self):
        l = []
        for i in range(self._min, self._max):
            l += self._rule.list(i)
        return l

    @memoizeu
    def unrank(self, i):
        if (i < 0):
            raise ValueError("Bound rule UNRANK : rank must be positive or null")
        count = 0
        for j in range(self._min, self._max):
            rc = self._rule.count(j)
            if (i < rc + count):
                return self._rule.unrank(j, i - count)
            count += rc
        raise ValueError("Bound rule UNRANK : rank is greater than the cardinal\
            of the set of objects")

    @memoizer
    def rank(self, obj):
        rank = 0
        for i in range (self._min, len(obj)):
            rank += self._rule.count(i)
        return rank + self._rule.rank(obj)
